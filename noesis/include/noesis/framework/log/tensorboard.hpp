/*!
 * @author    Mayank Mittal
 * @email     mittalma@student.ethz.ch
 * @author    Vassilios Tsounis
 * @email     tsounisv@ethz.ch
 * @author    David Hoeller
 * @email     dhoeller@ethz.ch
 *
 * Copyright (C) 2023 Robotic Systems Lab, ETH Zurich.
 * All rights reserved.
 * http://www.rsl.ethz.ch/
 */
#ifndef NOESIS_FRAMEWORK_LOG_TENSORBOARD_HPP_
#define NOESIS_FRAMEWORK_LOG_TENSORBOARD_HPP_

// C/C++
#include <iostream>
#include <thread>
#include <unordered_map>

// Eigen
#include <Eigen/Dense>

// Tensorflow
#include <tensorflow/core/util/events_writer.h>

// Noesis
#include "noesis/framework/system/filesystem.hpp"
#include "noesis/framework/utils/macros.hpp"
#include "noesis/framework/core/Object.hpp"

namespace noesis {
namespace log {

namespace internal {

/*!
 * @brief A simple wrapper to encapsulate and buffer signals to be visualized w/ TensorBoard.
 */
class TensorBoardSignal
{
public:
  
  /*!
   * @brief Default constructor
   * @note The default constructor is re-enabled in order for the this class to
   *       be usable w/ STL containers.
   */
  TensorBoardSignal() = default;
  
  explicit TensorBoardSignal(size_t buffer_capacity, size_t starting_step = 0);
  
  /*
   * Configuration
   */
  
  void setCapacity(size_t buffer_capacity);
  
  /*
   * Properties
   */
  
  size_t getStep() const;
  
  size_t getSize() const;
  
  size_t getCapacity() const;
  
  bool isFull() const;
  
  bool isEmpty() const;
  
  /*
   * Operations
   */
  
  void reset();
  
  bool append(const tensorflow::Event& event);
  
  bool write(tensorflow::EventsWriter& writer);
  
  friend inline std::ostream& operator<<(std::ostream& os, const TensorBoardSignal& rhs) {
    os << "\n    Buffer capacity: " << std::to_string(rhs.getCapacity());
    os << "\n    Buffer size: " << std::to_string(rhs.getSize());
    os << "\n    Current step: " << std::to_string(rhs.getStep());
    return os;
  }

private:
  std::vector<tensorflow::Event> events_;
  size_t stepCounter_;
};

} // namespace internal

/*!
 * @brief Helper struct for logger construction.
 */
struct TensorBoardLoggerConfig {
  //! If `path_prefix` is non-empty, the event file is placed in within a directory of that name.
  std::string path_prefix;
  //! A prefix to prepend to the filename of the event file generated by the logger instance.
  std::string log_prefix;
  //! The name of the logger instance. This should be unique within the owning scope.
  std::string name;
  //! The scope within which the logger instance is to belong.
  std::string scope;
  //! Set to true to enable verbose console output.
  bool verbose=false;
};

/*!
 * @brief C++ Front-end class for generating logging event files to visualize w/ TensorBoard.
 */
class TensorBoardLogger final: core::Object
{
public:
  
  // Aliases
  template <typename ScalarType_>
  using Vector = Eigen::Matrix<ScalarType_, Eigen::Dynamic, 1>;
  template <typename ScalarType_>
  using Matrix = Eigen::Matrix<ScalarType_, Eigen::Dynamic, Eigen::Dynamic>;
  
  /*
   * Instantiation
   */

  explicit TensorBoardLogger(const TensorBoardLoggerConfig& config);
  
  explicit TensorBoardLogger(
    const std::string& path_prefix,
    const std::string& log_prefix,
    const std::string& name,
    const std::string& scope,
    bool verbose=false);
  
  ~TensorBoardLogger() final;
  
  /*
   * Configurations
   */

  void setAutosaveEnabled(bool enable);
  
  void addLoggingSignal(const std::string& name, size_t buffer_capacity=1, size_t starting_step=0);
  
  /*
   * Properties
   */

  std::vector<std::string> getSignalNames() const;
  
  size_t getNumberOfSignals() const;
  
  size_t getSignalStep(const std::string& name);
  
  size_t getSignalSize(const std::string& name);
  
  size_t getSignalCapacity(const std::string& name);
  
  /*
   * Instance management operations
   */
  
  void startup();
  
  void shutdown();
  
  void reset();
  
  bool flush(const std::string& name);
  
  bool flush();
  
  /*
   * Data operations
   */
  
  template <typename ScalarType_>
  bool appendScalar(const std::string& name, ScalarType_ value);
  
  template <typename ScalarType_>
  bool appendVector(const std::string& name, const Vector<ScalarType_>& vector);
  
  template <typename ScalarType_>
  bool appendMatrix(const std::string& name, const Matrix<ScalarType_>& matrix);
  
  template <typename ScalarType_>
  bool appendHistogram(const std::string& name, const std::vector<ScalarType_>& values);
  
  template <typename ScalarType_>
  bool appendImageMatrix(const std::string& name, const Matrix<ScalarType_>& image_matrix, ScalarType_ min, ScalarType_ max);
  
  template <typename ScalarType_>
  bool appendImageMatrix(const std::string& name, const Matrix<ScalarType_>& image_matrix, bool normalize=false);
  
  bool appendImageString(const std::string& name, const std::string& image_string);
  
  /*
   * Helper functions
   */
  
  friend inline std::ostream& operator<<(std::ostream& os, const TensorBoardLogger& rhs) {
    auto name = rhs.namescope();
    os << "[" << name << "]: Signals:\n";
    for (const auto& signal: rhs.signals_) {
      os << "[" << signal.first << "]:" << signal.second << "\n";
    }
    os << "[" << name << "]: Filename:" << rhs.filename_;
    return os;
  }
  
private:

  double getWallClockTime() const;
  
  bool flushSignal(internal::TensorBoardSignal& signal);
  
  bool writeSignal(internal::TensorBoardSignal& signal);
  
  void assertSignalExists(const std::string& name) const;
  
  void checkSignalAppendResult(const std::string& name, bool result) const;
  
private:
  tensorflow::EventsWriter writer_;
  std::unordered_map<std::string, internal::TensorBoardSignal> signals_;
  std::string filename_;
  mutable std::mutex writerMutex_;
  mutable std::mutex signalsMutex_;
  bool autoSave_ = true;
  bool isActive_ = false;
};

} // namespace log
} // namespace noesis

// Include the template implementations
#include "noesis/framework/log/tensorboard.tpp"

#endif // NOESIS_FRAMEWORK_LOG_TENSORBOARD_HPP_

/* EOF */
